

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hardy.arbitrage package &mdash; hardy.py 0.1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> hardy.py
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">hardy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">hardy.py</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>hardy.arbitrage package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/hardy.arbitrage.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="hardy-arbitrage-package">
<h1>hardy.arbitrage package<a class="headerlink" href="#hardy-arbitrage-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-hardy.arbitrage.arbitrage">
<span id="hardy-arbitrage-arbitrage-module"></span><h2>hardy.arbitrage.arbitrage module<a class="headerlink" href="#module-hardy.arbitrage.arbitrage" title="Permalink to this headline">¶</a></h2>
<p>Created on Tue Apr 21 19:04:32 2020
&#64;author: hurtd</p>
<p>WRAPPING PACKAGE to Combine “Hanlding” and “Transformations” to produce
Data To Plot on Demand and deliver to the Image Processing f(n)s</p>
<blockquote>
<div><p>This package will contain several ‘sections’:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>__Perform <a href="#id3"><span class="problematic" id="id4">Transformation__</span></a>: Wrapper function(s) to actually /do/ the</dt><dd><p>transformations. This MAY be smart-ish and perform only specified
ones, perhaps from a CONFIG or LIST? (That List and Config
is an idea we’ll talk about in __yNot__ probably!)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>__Association Functions:__ This is optional, but once you’ve done</dt><dd><p>the transformations (or before?) you can check how well the data
CORRELATES/ASSOCIATES, both to itself and to a “Standard” dataset
AKA starting with linear data and transforming it!
This may give us “SCORES” for each transformation,
which we can use to prioritize!</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>__Timeline + <a href="#id3"><span class="problematic" id="id5">Milestones__</span></a>:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>2020-04-21: List of the high-priority functions and</dt><dd><p>Simple-Transformations, with progress and
timeline to get them all done soon.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2020-04-28: Passing Tests and can __HAND <a href="#id3"><span class="problematic" id="id6">OFF__</span></a> to the classifier - a</dt><dd><p>DataFrame of “all” the transformed data columns.
Recieve Handoff from handling, and begin to Integrate.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2020-05-12: Complex Transforms - consider what other things we may want,</dt><dd><p>and discuss feedback with group</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2020-06-09: Make Decision on Association functions and __HAND <a href="#id3"><span class="problematic" id="id7">OFF__</span></a></dt><dd><p>if so. Otherwise, simply focus on new group priorities</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2020-06-23: IF yNot function is doing Configuration ideas, make</dt><dd><p>Stretch-Goal learning gameplan… TBD…</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>__Current <a href="#id3"><span class="problematic" id="id8">Status__</span></a>:</dt><dd><ul class="simple">
<li><p>(2020-04-14)</p></li>
<li><p>Just creating files and setup, no progress yet</p></li>
<li><p>Planning Functions, in compontent spec document (here!)</p></li>
<li><p>Considering how much to Frankenstien from prior work. Configuration?</p></li>
</ul>
</dd>
</dl>
<p>__Module <a href="#id3"><span class="problematic" id="id9">List__</span></a>:</p>
</div></blockquote>
<p>### <em>SECTION: Perform Transformation</em>
#### get_xy():</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>Uses handling.py to load a file, check that we have xy data,</dt><dd><p>and do a quick analysis on it!</p>
</dd>
</dl>
</li>
<li><p>INPUT: file name</p></li>
<li><dl class="simple">
<dt>OUTPUT: each of 1D arrays X and Y, plus messages OR list of</dt><dd><p>“Approved” transformations??</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl>
<dt>#### perform_transform():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Wrapping function, to take some input data and return a</dt><dd><p>dataframe with every transform that we want to use:</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>INPUT: 1D arrays X, Y, some sort of list or guiance for what</dt><dd><p>transforms to do</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>OUTPUT: Pandas dataframe of X and Y with all of their transforms</dt><dd><p>as requested.</p>
</dd>
</dl>
</li>
<li><p>NOTE: There might be a better way to do this -</p></li>
</ul>
</dd>
<dt>#### generate_linear_transforms():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Creates a “sample” linear 2D dataset, possibly following</dt><dd><p>range instructions, and performs all(?) transforms on the data</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>INPUT: [ALL OPTIONAL? Default 0-1 and X=Y], [List of transforms to do??</dt><dd><p>default True to perform “ALL”]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>OUTPUT: pandas dataframe with all X-transformationa and all</dt><dd><p>Y-transformations - (Maybe in Standard names? Maybe Not?)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>NOTE: This could get messy - And maybe use the same wrapping function</dt><dd><p>above to perform the listed tranforms?</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>### <em>SECTION: Association Functions</em></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>NOTE: Not really planning these yet, that will be scoped or</dt><dd><p>descoped based on Team Update by __2020-<a href="#id3"><span class="problematic" id="id10">04-28__</span></a></p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### setup_correlation_matrix():</dt><dd><ul class="simple">
<li><p>Sets up the 2D matrix of “scores” to judge the correlations</p></li>
</ul>
</dd>
<dt>#### correlate_to_transforms():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>For a given transform, determine (?) how correlated the</dt><dd><p>data is to all other columns in the dataframe</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### correlate_to_linear():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Compares the given transform to the linear_transform()</dt><dd><p>function transforms. Any that correlate are probably good ideas?!?</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### correlate_to_null():</dt><dd><blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>Maybe compares the given transform to a flat line of low but</dt><dd><p>nonzero values (all value = 0.1)?</p>
</dd>
</dl>
</li>
<li><p>Not sure what’s the best way to do this…</p></li>
<li><dl class="simple">
<dt>What I’m TRYING to do is to identify/flag “BORING” data, which are</dt><dd><p>probably BAD transforms to use?</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>#### grade_all_transforms():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Wrapping function. Given a “fully” transformed dataset</dt><dd><p>(or generate it here?), run all correlations and use some
fancy math or grading (we generate?) to give each column a “SCORE”</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The __SCORE__ should reflect how “Interesting” we think the data</dt><dd><p>is (which is a topic for discussion, but all zeros is
not interesting)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>INPUT: dataframe ready to be “graded”, OR give an XY dataset and</dt><dd><p>we’ll call the transform functions on it</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>OUTPUT: dictionary of Key,Values where each Key is a transform</dt><dd><p>(or column key), and each Value is a “grade” to estimate
how interesting we think the data may be</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>NOTE: This is SUPER arbitrary and is the ‘creative’ part of the</dt><dd><p>STRETCH-GOALS of the project.s!</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### grade_all_files():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Load all the files in a list, perform transformations, and grade.</dt><dd><p>Hopefully this is a fast function so you can do a large
list of files.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Then combine all the grades to get an average idea of what</dt><dd><p>transforms we consider “good”</p>
</dd>
</dl>
</li>
<li><p>INPUT: list of files</p></li>
<li><dl class="simple">
<dt>OUTPUT: dictionary of key, values as before, where results</dt><dd><p>are averaged across dataset</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ACTIONS: Optionally, save results as a report csv (or append to</dt><dd><p>existing csv report??), to track grades over time</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### load_transform_results():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>IF we’ve run this program before, we should have a file that has</dt><dd><p>previous “grades”, this time based on the model training</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If one transform shows up in a lot of the best-performing models,</dt><dd><p>we should bump it to the top of the Transform To-Do List!</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### combine_grades_results():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Somehow we should combine the ‘grades’ with the ‘prior results’</dt><dd><p>to get our new guess for what are the ‘best’ transformations to try</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>this will allow our model to do the highest-profile transfomations</dt><dd><p>first and hopefully get good results in fewer attempts.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py function">
<dt id="hardy.arbitrage.arbitrage.apply_tform">
<code class="sig-prename descclassname">hardy.arbitrage.arbitrage.</code><code class="sig-name descname">apply_tform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">raw_df</span></em>, <em class="sig-param"><span class="n">tform_commands</span></em>, <em class="sig-param"><span class="n">rgb_col_number</span><span class="o">=</span><span class="default_value">6</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.arbitrage.apply_tform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw_df</strong> (<em>pd.DataFrame of raw data from list_of_tuples</em>) – <p>Un-Transformed data to apply transform to.
This will be a call of list_of_tuples[#][1], because as</p>
<blockquote>
<div><p>defined elsewhere, each raw data has one tuple in list,
contains (Filename, DataFrame, classifier)</p>
</div></blockquote>
</p></li>
<li><p><strong>tform_commands</strong> (<em>List of Tform Commands</em>) – <p>This will be a call of tform_command_dict[tform_command_list[#]],
Thus it will contain a list of tform commands:</p>
<blockquote>
<div><p>(Index=0, transform, source),
(Index=1, transform, source),
(Index=2, transform, source),
As explained elsewhere</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>tform_df</strong> –</p>
<dl class="simple">
<dt>Each column is placed in “Index”, and gets its name from “source”</dt><dd><p>(New name from SourceColumnName__tform__TformName)</p>
</dd>
<dt>Each column’s data is ouput of the tform_1d1d function called</dt><dd><p>and the remainder are passed as zero (with # as col name?)</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.arbitrage.import_tform_config">
<code class="sig-prename descclassname">hardy.arbitrage.arbitrage.</code><code class="sig-name descname">import_tform_config</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tform_config_path</span><span class="o">=</span><span class="default_value">'.\tform_config.yaml'</span></em>, <em class="sig-param"><span class="n">raw_df</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.arbitrage.import_tform_config" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tform_config_path</strong> (<em>Str</em><em>, </em><em>optional</em>) – Path of transform configuration file to
DESCRIPTION. The default is ‘.  form_config.yaml’.</p></li>
<li><p><strong>CHECKS</strong> – </p></li>
<li><p><strong>------</strong> – </p></li>
<li><p><strong>Index are in 0-5</strong><strong> (</strong><strong>for RGBrgb-style plotting</strong><strong>)</strong> (<em>All</em>) – </p></li>
<li><p><strong>transform commands are in transform.list_1d1d</strong> (<em>All</em>) – </p></li>
<li><p><strong>source # are below the length of the raw-data list</strong> (<em>All</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>tform_command_list</strong> (<em>list of str</em>) – Ordered list of transform commands to use.
Differs from the dict.keys() because this is ordered!
(May save Report with this string as the key, to be looked up?)</p></li>
<li><p><strong>tform_command_dict</strong> (<em>dict of List-of-Transform-tuples</em>) – Each key will return a list of transforms to do on this data loop.
Each “List of Transforms” as stated elsewhere contain:</p>
<blockquote>
<div><p>(Index=0, transform, source),
(Index=1, transform, source),
(Index=2, transform, source),
etc. where:
“Index” is the output column destination,
“transform” is command in transform.list_1d1d, and
“source” is the raw data column to be used in the tform</p>
</div></blockquote>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.arbitrage.tform_tuples">
<code class="sig-prename descclassname">hardy.arbitrage.arbitrage.</code><code class="sig-name descname">tform_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">list_of_tuples</span></em>, <em class="sig-param"><span class="n">tform_commands</span></em>, <em class="sig-param"><span class="n">rgb_format</span><span class="o">=</span><span class="default_value">'RGBrgb'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.arbitrage.tform_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping function to apply a list of transform commands to each
dataframe in the list_of_tuples, and replace it with a same-format
list_of_tuples containing transformed data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_of_tuples</strong> (<em>List of Tuples</em>) – Described in depth elsewhere. Standardized list for each raw file,
tuple in format (filename_str, DataFrame, label)</p></li>
<li><p><strong>tform_commands</strong> (<em>List of List</em><em>(</em><em>3</em><em>)</em>) – Described in depth elsewhere</p></li>
<li><p><strong>rgb_format</strong> (<em>str</em><em>, </em><em>optional</em>) – String of how we will parse the output files.
Input here to get the output dataframe size.
The default is “RGBrgb”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transformed_tuples</strong> – Formatted the same as the input list, but each DataFrame is
replaced with the Transformed DF.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List of Tuples</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-hardy.arbitrage.transformations">
<span id="hardy-arbitrage-transformations-module"></span><h2>hardy.arbitrage.transformations module<a class="headerlink" href="#module-hardy.arbitrage.transformations" title="Permalink to this headline">¶</a></h2>
<p>Created on Tue Apr 21 19:04:12 2020
&#64;author: hurtd</p>
<dl class="simple">
<dt>The first-level functions, which will take input data</dt><dd><p>(either 2D, 3D, or eventually nD…), and perform transformations
to generate the full set of data-columns that we will test against!</p>
</dd>
</dl>
<p>THIS FILE IS FOR MATHEMATICAL TRANSFORMATIONS THEMSELVES.
DATA WILL BE PROCESSED IN THE “ARBITRAGE.py” FILE</p>
<blockquote>
<div><dl class="simple">
<dt>This package will contain several ‘sections’:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>__Transformation Functions:__ This is the mathematical side,</dt><dd><p>and to start out we will be able to perform a variety
of 1D or 2D transformations such as Log, Inverse, accumulate,
Integrate, derrive, etc.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>__Complex <a href="#id3"><span class="problematic" id="id11">Transforms__</span></a>: Some data transformations are combinations of</dt><dd><p>the ones above (you can integrate AFTER you log-ify,
for instance)</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>__Timeline + <a href="#id3"><span class="problematic" id="id12">Milestones__</span></a>:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>2020-04-21: List of the high-priority functions and</dt><dd><p>Simple-Transformations, with progress and
timeline to get them all done soon.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2020-04-28: Passing Tests and can __HAND <a href="#id3"><span class="problematic" id="id13">OFF__</span></a> to the classifier - a</dt><dd><p>DataFrame of “all” the transformed data columns.
Recieve Handoff from handling, and begin to Integrate.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2020-05-12: Complex Transforms - consider what other things we may want,</dt><dd><p>and discuss feedback with group</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2020-06-09: Make Decision on Association functions and __HAND <a href="#id3"><span class="problematic" id="id14">OFF__</span></a></dt><dd><p>if so. Otherwise, simply focus on new group priorities</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2020-06-23: IF yNot function is doing Configuration ideas, make</dt><dd><p>Stretch-Goal learning gameplan… TBD…</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>__Current <a href="#id3"><span class="problematic" id="id15">Status__</span></a>:</dt><dd><ul class="simple">
<li><p>(2020-04-14)</p></li>
<li><p>Just creating files and setup, no progress yet</p></li>
<li><p>Planning Functions, in compontent spec document (here!)</p></li>
<li><p>Considering how much to Frankenstien from prior work. Configuration?</p></li>
</ul>
</dd>
</dl>
<p>__Module <a href="#id3"><span class="problematic" id="id16">List__</span></a>:</p>
<p>### <em>SECTION: Basic 1D Transformations</em></p>
</div></blockquote>
<dl class="simple">
<dt>#### transform_log():</dt><dd><ul class="simple">
<li><p>INPUT: 1D data array with NO NEGATIVE VALUES</p></li>
<li><p>OUTPUT: Logrythmic transform of that data</p></li>
<li><dl class="simple">
<dt>Note: Consider shifting or abs() for negative data?</dt><dd><p>no? simply don’t call log transform for negative data?</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### transform_reciprocal():</dt><dd><ul class="simple">
<li><p>INPUT: 1D data array - Limits tbd?</p></li>
<li><p>OUTPUT: all values inverted (1/x)</p></li>
<li><p>Note: twice should return itself!</p></li>
</ul>
</dd>
<dt>#### transform_cumsum():</dt><dd><ul class="simple">
<li><p>INPUT: 1D data array -</p></li>
<li><p>OUTPUT: cumulative sum of data (aka integrated with unit-steps)</p></li>
<li><p>Note: Not in high priority list?</p></li>
</ul>
</dd>
<dt>#### transform_1d_derrivative():</dt><dd><ul class="simple">
<li><p>INPUT: 1D data array</p></li>
<li><p>OUTPUT: the step-by-step delta (Note: copy last delta to retain length?)</p></li>
<li><dl class="simple">
<dt>Note: Also not in high-priority list? Should also be able to complete</dt><dd><p>the loop w/ cumsum.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### transform_exp():</dt><dd><ul class="simple">
<li><p>INPUT: 1D data array - Limits?</p></li>
<li><p>OUTPUT: e^x of each datapoint.</p></li>
<li><dl class="simple">
<dt>Note: may be redundant in general with log? should be able to</dt><dd><p>complete that loop!</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### transform_0to1():</dt><dd><ul class="simple">
<li><p>INPUT: 1D data array, data handling case instructions</p></li>
<li><dl class="simple">
<dt>OUTPUT: that array shifted and scaled to the 0-to-1 basis</dt><dd><p>(by FIRST shifting to min=0, THEN scaling to max=1)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Note: option to leave data alone if min is already 0-to-1,</dt><dd><p>or if max After Shift is already 0-to-1
(case: data begins 0.2-0.4, can either scale 0-1 or leave as is!)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Note2: BETTER scaling is to devine 0 as -MAX(ABS(Data))</dt><dd><p>and 1 as +MAX(ABS(Data)). This maintains fidelity of absolute Y data</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### transform_pm1():</dt><dd><ul class="simple">
<li><p>INPUT: 1D data array, data handling case instructions</p></li>
<li><dl class="simple">
<dt>OUTPUT: that array shifted and scaled to the 0-to-1 basis</dt><dd><p>[THIS TIME: 0=(-,MaxAbs(X)), and 1 =(+MaxAbs(X))]</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>### <em>SECTION: Basic 2D Transformations</em></p>
<dl class="simple">
<dt>#### transform_2D_int():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>INPUT: 2 equal size 1D arrays Y, X, to be integrated (Y)dx -</dt><dd><p>[Optional offset value? to use as the Plus-C]</p>
</dd>
</dl>
</li>
<li><p>OUTPUT: The integral of Y dx (BOX? Trapz?) - offset if instructed to.</p></li>
<li><dl class="simple">
<dt>Note: Error handling? What if not Sorted/Linear in X?</dt><dd><p>Should we sort by X first? (Or, what if reciprocating
data ie CV Sweeps?)</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### transform_2D_der():</dt><dd><ul class="simple">
<li><p>INPUT: 2 equal size 1D arrays Y, X - Sorted? in either?</p></li>
<li><dl class="simple">
<dt>OUTPUT: the Single-point derivatives dY/dX, also the offset so</dt><dd><p>you /could/ integrate it back again!</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Note: could use some sort of average or smoothing to reduce noise?</dt><dd><p>However that would be LOSSY DATA PRACTICE!</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### transform_prod():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>INPUT: 2 equal size 1D arrays X, Y , [Optional Power arguments?</dt><dd><p>or do those in the 1D cases and use as inputs?]</p>
</dd>
</dl>
</li>
<li><p>OUTPUT: Product of each x*y, maybe with power-math included (options)</p></li>
</ul>
</dd>
<dt>### <em>SECTION: More Complex Transformations</em></dt><dd><dl class="simple">
<dt>#### transform_fourier_wavelets():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Ok so this is the only High-Priority one that I’m genuinely</dt><dd><p>concerned with… while you “CAN” try to do a transform on
a whole dataset, that gets noisy and lossy.</p>
</dd>
<dt>What I want to investigate is “Wavelet Filtering” Fourier transform,</dt><dd><p>which we learned about at a Data Sci seminar last quarter?
(Or otherwise, there’s a whole realm of Signal-transforming
science, I can research that…)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>INPUT:  2 equal size 1D arrays X, Y - Sorted in X??</dt><dd><p>(Frequency range parameters? or is that the X-size?)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>OUTPUT: 2D? output matrix or Meshgrid - in X-Freq space</dt><dd><p>(for each wavelet size, return the match(-1 to 1?)*amplitude
at each X?)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>NOTE: This will have to be a group discussion- we need TEST DATA</dt><dd><p>that should work in this space, and then we can report that back!</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### multi_transform():</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Wrapping function, to perform multiple transformations all together…</dt><dd><p>Not sure which of these may be useful but I can see possible
value in knowing the integral of a log function, for example.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>INPUT: X, [Y if 2D], Multiple transforms to perform…</dt><dd><p>Is this what classes are for??</p>
</dd>
</dl>
</li>
<li><p>OUTPUT: Data output from the final transform listed.</p></li>
<li><dl class="simple">
<dt>NOTE: This is low-priority, and should only be done if we convince</dt><dd><p>ourselves that it’s useful… RELATED, if we get the “Smart”
learning functionality, maybe we can combine things this way</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>#### transform___():</dt><dd><ul class="simple">
<li></li>
<li><p>INPUT:</p></li>
<li><p>OUTPUT:</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py data">
<dt id="hardy.arbitrage.transformations.list_1d2d">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">list_1d2d</code><em class="property"> = {'1d_cwt': &lt;function transform_1d_cwt&gt;}</em><a class="headerlink" href="#hardy.arbitrage.transformations.list_1d2d" title="Permalink to this definition">¶</a></dt>
<dd><p># ==========================================================================
# test zone (Note: Uncomment Matplotlib at top of file!</p>
<p>x_linear = np.linspace(0, 20, 1000)
y_test = 10 * np.sin(2 * np.pi * 0.1 * x_linear) +             1 * np.sin(2 * np.pi * 5 * x_linear)
test_df = pd.DataFrame(data={“Xlinear”: x_linear, “Ytest”: y_test})
# Valid Test: Pass Test_df and the Y-axis transform to get output df
# of the Y-test data.
fig, ax = plt.subplots(2, 1)
result_1 = transform_1d_cwt(test_df, ‘y’)
ax[0].imshow(result_1, cmap=’PRGn’)
ax[1].plot(x_linear, y_test)
fig, ax2 = plt.subplots(2, 1)</p>
<p>y_chirp = signal.chirp(x_linear, 2, 20, 0.001)
result_2 = transform_1d_cwt(y_chirp)
ax2[0].imshow(result_2, cmap=’PRGn’)
ax2[1].plot(x_linear, y_chirp)
# ==========================================================================</p>
</dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.transformations.transform_1d_cumsum">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">transform_1d_cumsum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">raw_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.transformations.transform_1d_cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>The function return the cumulative sum of input array</p>
<p>raw_array: Input numpy array</p>
<dl class="simple">
<dt>log_array: np.ndarray</dt><dd><p>cumulative sum of values in the input array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.transformations.transform_1d_cwt">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">transform_1d_cwt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">raw_df</span></em>, <em class="sig-param"><span class="n">xy</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.transformations.transform_1d_cwt" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform to execute a “Continuous Wavelet Transform” on a 1d data array
pass it a raw XY data and tell it which column to use for the transform.
See Documentaion on CWT transform:</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/">https://docs.scipy.org/doc/scipy/reference/generated/</a>
scipy.signal.cwt.html#scipy.signal.cwt</p>
</div></blockquote>
<dl class="simple">
<dt>Note: I need to do testing to understand the in/outputs here…</dt><dd><p><a href="#id1"><span class="problematic" id="id2">*</span></a>Plan is to simply hard-code a certain type of Wavelet to use… and
Output Data may not be able to be square… In that case, we will
discuss how to integrate this result with the compression of the data.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw_df</strong> (<em>pandas.DataFrame</em><em> or </em><em>1D array</em><em> (</em><em>Mx2</em><em> or </em><em>Mx1</em><em>)</em>) – the raw data which is to be transformed.</p></li>
<li><p><strong>xy</strong> (<em>boolean</em><em>, or </em><em>string 'x'</em><em>, or </em><em>'y'</em>) – information on which dataframe column to transform.
ignored if an 1D array is passed instead.</p></li>
<li><p><strong>w_method</strong> (<em>string</em><em> or </em><em>boolean?</em>) – input instructions guiding how to choose wavelet sizes.
default should be linear, with options for log- or exponential?
(Will have to experiment with data to discover best option)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cwt_matrix</strong> – Square M-by-M matrix of the wavelet transform data
(Not yet compressed to plottable 0-1 data)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray (MxM)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.transformations.transform_1d_derivative">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">transform_1d_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">raw_array</span></em>, <em class="sig-param"><span class="n">spacing</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.transformations.transform_1d_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that outputs the gradient of 1-D array using
numpy.gradient function</p>
<p>raw_array: numpy array
spacing: int representing the spacing between each datapoint</p>
<dl class="simple">
<dt>derivative_array: np.ndarray</dt><dd><p>array representing gradient at each datapoint</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.transformations.transform_1d_exp">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">transform_1d_exp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">raw_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.transformations.transform_1d_exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.transformations.transform_1d_log">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">transform_1d_log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">raw_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.transformations.transform_1d_log" title="Permalink to this definition">¶</a></dt>
<dd><p>The function that outputs the natural log of input array</p>
<p>raw_array: Input numpy array</p>
<dl class="simple">
<dt>log_array: np.ndarray</dt><dd><p>natural log values of each element in the input array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.transformations.transform_1d_none">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">transform_1d_none</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">raw_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.transformations.transform_1d_none" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.transformations.transform_1d_reciprocal">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">transform_1d_reciprocal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">raw_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.transformations.transform_1d_reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>The function the outputs the reciprocal of input array</p>
<p>raw_array: Input numpy array</p>
<dl class="simple">
<dt>log_array: np.ndarray</dt><dd><p>reciprocal values of each element in the input array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hardy.arbitrage.transformations.transform_array_multiplication">
<code class="sig-prename descclassname">hardy.arbitrage.transformations.</code><code class="sig-name descname">transform_array_multiplication</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hardy.arbitrage.transformations.transform_array_multiplication" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that multiplies two arrays x &amp; y, element
by element. If y is None, it return x*x</p>
<dl class="simple">
<dt>x: numpy.array</dt><dd><p>numpy array representing the one array to be multiplied</p>
</dd>
<dt>y: numpy.array</dt><dd><p>numpy array representing the second array to be multiplied
if None it the module will square the x array</p>
</dd>
</dl>
<dl class="simple">
<dt>multi_array: numpy.array</dt><dd><p>numpy array representing the one to one multiplication
of two arrays</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-hardy.arbitrage.version">
<span id="hardy-arbitrage-version-module"></span><h2>hardy.arbitrage.version module<a class="headerlink" href="#module-hardy.arbitrage.version" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-hardy.arbitrage">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-hardy.arbitrage" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Maria Politi, Abdul Moeez,              David Hurt

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>